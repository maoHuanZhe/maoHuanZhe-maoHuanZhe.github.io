---
title: 监控瓶颈
date: 2022-04-19 20:54:21
permalink: /pages/a4c880/
categories:
  - Elasticsearch
tags:
  - Elasticsearch
  - 管理集群
  - 监控
author: 
  name: 樊光瑞
  link: https://github.com/maoHuanZhe
---
`Elasticsearch` 通过它的 `API` 接口提供了丰富的信息：内存消耗、节点成员、分片分发以及 `I/O` 的性能。集群和节点 `API` 测量集群的健康状况和整体的性能指标。理解集群的诊断数据并预估集群的整体状态，将提醒用户注意性能的瓶颈，如未分配的分片和消失的节点，这样就可以轻而易举地解决这些问题。
## 检查集群的健康状态
集群的健康 `API` 接口提供了一个方便但略有粗糙的概览，包括集群、索引和分片的整体健康状况。这通常是发现和诊断集群中常见问题的第一步。代码清单 11-3 展示了如何使用集群健康 `API` 来检查整体的集群状态。
::: warning 代码清单 11-3 集群健康 API 的请求
``` http
GET /_cluster/health
{
  "cluster_name" : "FGRAPP",
  "status" : "green",//集群状态指示器:方便的集群整体健康指示器
  "timed_out" : false,
  "number_of_nodes" : 3,//集群中节点的总数量
  "number_of_data_nodes" : 3,//集群中存放数据的节点总数量
  "active_primary_shards" : 25,//集群中全部索引的主分片总数量
  "active_shards" : 50,//集群中全部索引的所有分片、包括主分片和副本分片的总数量
  "relocating_shards" : 0,//当下正在多个节点间移动的分片数量
  "initializing_shards" : 0,//新创建的分片数量
  "unassigned_shards" : 0,//集群中定义、却未能发现的分片数量
  "delayed_unassigned_shards" : 0,//分配因超时设置而延迟的分片数量。
  "number_of_pending_tasks" : 0,//尚未执行的集群级更改的数量
  "number_of_in_flight_fetch" : 0,//未完成的fetches的数量
  "task_max_waiting_in_queue_millis" : 0,//自最早启动任务以来以毫秒为单位表示的时间正在等待执行
  "active_shards_percent_as_number" : 100.0//集群中活性分片的比例以百分比表示。
}
```
:::
从这个答复的表明信息，用户就可以推断出很多关于集群整体健康状态的信息，不过除了第一眼能看出的明显内容，还有很多可以解读的地方。让我们深入理解一下代码中 3 个指示器的含义：`relocating_shards`、`initializing_shards` 和 `unassigned_shards` 。
- `relocating_shards`——大于 0 表示 `Elasticsearch` 正在集群内移动数据的分片，来提升负载均衡和故障转移。这通常发生在添加新节点、重启失效的节点或者删除节点的时候，因此出现了这种临时的现象。
- `initializing_shards`——当用户刚刚创建一个新的索引或者重启一个节点的时候，这个数值会大于 0。
- `unassigned_shards`——这个值大于 0 的最常见原因是有尚未分配的副本分片。在开发环境中，这个问题很普遍，因为单节点的集群其索引默认有 5 个分片和 1 个副本分片。这种情况下，由于无多余节点来分配副本分片，因此还有 5 个未分配的副本分片。
从输出结果的第一行可以看出，集群的状态是绿色的。有时也不一定如此，如节点无法启动或者从集群中掉出的情况。尽管状态值只是给你一个大致的集群健康状态，理解状态值对于集群性能的含义还是很有价值的。
- 绿色——主分片和副本分片都已经分发而且运作正常。
- 黄色——通常这是副本分片丢失的信号。这个时候，`unassigned_shards` 的值很可能大于 0，使得集群的分布式本质不够稳定。进一步的分片损坏将导致关键数据的缺失。查看任何没有正确地初始化或运作的节点。
- 红色——这是危险的状态，无法找到集群中的主分片，使得主分片上的索引操作不能进行，而且导致了不一致的查询结果。同样，很可能一个或多个节点从集群中消失。
有了这些知识，用户现在可以查看一个黄色状态的集群，并试图跟踪问题的根源。
```
GET /_cluster/health
{
  "cluster_name" : "FGRAPP-test",
  "status" : "yellow",
  "timed_out" : false,
  "number_of_nodes" : 1,
  "number_of_data_nodes" : 1,
  "active_primary_shards" : 10,
  "active_shards" : 10,
  "relocating_shards" : 0,
  "initializing_shards" : 0,
  "unassigned_shards" : 2,
  "delayed_unassigned_shards" : 0,
  "number_of_pending_tasks" : 0,
  "number_of_in_flight_fetch" : 0,
  "task_max_waiting_in_queue_millis" : 0,
  "active_shards_percent_as_number" : 83.33333333333334
}
```
给定这个 `API` 请求及其返回结果，用户可以看到目前集群处于黄色状态，根据之前所学，可能的罪魁祸首是 `unassigned_shards` 值大于 0 了。集群健康 `API` 提供了更多的细粒度的操作，允许用户进一步地诊断问题。在这个例子中，可以通过添加 `level` 参数，深入了解哪些索引受到了分片未配置的影响。
``` http
GET /_cluster/health?level=indices
{
 "cluster_name" : "FGRAPP-test",
  "status" : "yellow",
  "timed_out" : false,
  "number_of_nodes" : 1,
  "number_of_data_nodes" : 1,
  "active_primary_shards" : 10,
  "active_shards" : 10,
  "relocating_shards" : 0,
  "initializing_shards" : 0,
  "unassigned_shards" : 2,
  "delayed_unassigned_shards" : 0,
  "number_of_pending_tasks" : 0,
  "number_of_in_flight_fetch" : 0,
  "task_max_waiting_in_queue_millis" : 0,
  "active_shards_percent_as_number" : 83.33333333333334,
  "indices" : {
    "index-test-yellow" : {
      "status" : "yellow",
      "number_of_shards" : 2,
      "number_of_replicas" : 1,
      "active_primary_shards" : 2,
      "active_shards" : 2,
      "relocating_shards" : 0,
      "initializing_shards" : 0,
      "unassigned_shards" : 2
    }
  }
}
```
单节点集群遭遇了一些问题，原因是 `Elastiesearch` 试图在集群内分配副本分片，但是由于只有一个节点在运行，它无法进行下去。这导致了副本分片未能分发到各处，所以集群的状态是黄色的，如图 11-3 所示。
正如你所见，一个简单的弥补方式是向集群中加入节点，这样 `Elasticsearch` 就能将副本分片配置到这个位置。请确保所有的节点都在运行而且可访问，这是解决黄色状态问题最简单的方法。
::: center 
![Elasticsearch](https://cdn.jsdelivr.net/gh/maoHuanZhe/image@main/20220424/Elasticsearch.6g1wdhofqh34.webp)
![Elasticsearch](https://cdn.jsdelivr.net/gh/maoHuanZhe/image@main/20220424/Elasticsearch.1owwovxl7uxs.webp)
图 11-3 通过更多的可访问节点，让黄色状态的问题得以解决
:::
## CPU：慢日志、热线程和线程池
监控 `Elasticsearch` 集群可能会不时地暴露 `CPU` 使用的突发高峰，或者是持续高 `CPU` 使用率、阻塞/等待线程导致的性能瓶颈。本节将阐明一些可能的性能瓶颈，并提供必要的工具让用户侦测并解决这些问题。
### 慢日志
`Elasticsearch` 提供了两项日志来区分慢操作，它们很容易在集群配置文件中设置：慢查询日志和慢索引日志。默认情况下两者都是关闭的。日志输出是分片级别的。因此在相应的日志文件中，一个操作可能由若干行表示。分片级别日志的好处在于，用户可以根据日志输出更好地定位有问题的分片和节点，如下所示。请注意这些设置可以通过 `(index_name/_settings` 端点进行修改。
``` http
PUT /index-test/_settings
{
  "index": {
    "search" :{
      "slowlog" :{
        "threshold": {
          "query": {
            "warn": "10s",
            "info": "1s",
            "debug": "2s",
            "trace": "500ms"
          },
          "fetch": {
            "warn": "1s",
            "info": "1s",
            "debug": "500s",
            "trace": "200ms"
          }
        }
      }
    }
  }
}
```
如你所见，可以为搜索的两个阶段设置阈值：查询和获取。日志的级别（警告-`war n`、信息-`info`、调试-`debug` 和跟踪-`trace`）允许用户细粒度地控制何种级别的内容要被记录下来，当想简单地查找(`grep`)日志文件时这一点很方便。在 `log4j2.properties` 文件中，可以配置存放日志输出的实际文件以及其他一些日志 功能，如下所示。
```

```
典型的慢日志文件输出看上去是这样的:
```

```
### 慢查询日志
对于识别性能问题，你会感兴趣的一个重要部分是查询的时间：`took[##ms]`。此外，了解相关的分片和索引也是很有帮助的，这些都是通过`[index][shard number]`符号来标识的，在这个例子中它是 [streamglue] [4]。
### 慢索引日志
在发现索引操作过程中的瓶颈时，同样有价值的是慢索引日志。它的阈值是在集群配置文件中定义，或者是通过索引更新设置的 `API ` 接口定义，和之前的慢日志相似
``` http
PUT /index-test/_settings
{
  "index": {
    "indexing" :{
      "slowlog" :{
        "threshold": {
          "index": {
            "warn": "10s",
            "info": "1ms",
            "debug": "2s",
            "trace": "500ms"
          }
        }
      }
    }
  }
}
```
和之前一样，任何达到阈值的索引操作将被写入到日志文件，而且用户将看到索引操作的索引名和分配数 `[Iindex] Ishard number] ( rbitbucket][2]）`和持续时间(`took [4 .5ms]`)。
```

```
发现慢查询和慢索引请求出现在哪里，对于纠正 `Elasticsearch` 的性能问题大有帮助。容忍性能低下的行为无限制地增长，可能会导致整个集群中的失败逐渐累积，最终集群完全崩溃。
### 热线程 API接口
如果遇到过集群的 `CPU` 使用率居高不下，则将发现热线程(`hot threads`) `API` 对于识别被阻塞并导致问题的具体进程，是很有用处的。这里热线程 `API` 提供了集群中每个节点上的一系列阻寨线程。请注意，和其他 `API` 接口不同，热线程并不返回 `JSON` 格式的内容，而是如下格式化的文本：
```
GET /_nodes/hot_threads
```
下面是输出的样例：
```
::: {node1}{-_RCA5-dRVKpG6fcQ5l9sw}{UsPlHiT0RrCHhhX2rTWrvA}{fgrapp1}{82.157.68.63:9300}{cdfhilmrstw}{ml.machine_memory=3917721600, xpack.installed=true, ml.max_jvm_size=536870912}
   Hot threads at 2022-04-24T09:08:43.790Z, interval=500ms, busiestThreads=3, ignoreIdleThreads=true:
   
   100.0% [cpu=1.0%, other=99.0%] (500ms out of 500ms) cpu usage by thread 'elasticsearch[node1][search][T#6]'
     3/10 snapshots sharing following 23 elements
```
为了正确地理解，热线程 `API` 的输出需要一些解析，让我们看看它提供了哪些关于 `CPU ` 性能的信息：
```
::: {node1}{-_RCA5-dRVKpG6fcQ5l9sw}{UsPlHiT0RrCHhhX2rTWrvA}{fgrapp1}{82.157.68.63:9300}{cdfhilmrstw}{ml.machine_memory=3917721600, xpack.installed=true, ml.max_jvm_size=536870912}
```
结果的第一行包括了节点的身份。因为集群很可能有多于一个的节点，这是线程信息属于哪个 `CPU` 的第一个标识。
```
 100.0% [cpu=1.0%, other=99.0%] (500ms out of 500ms) cpu usage by thread 'elasticsearch[node1][search][T#6]'
```
这里可以看到 `100.0%` 的CPU 处理花费在了搜索（`search`）线程上。这对于你的理解很关键，因为可以调优导致 `CPU` 高峰的搜索查询。希望这里不要总是出现搜索。`Elasticsearch ` 可能显示其他的值，如 `merge`、`index`，来表明此线程进行的操作。由于 `cpu usage` 的标识，你知道了这是和 `CPU` 相关的。其他可能的输出标识有阳塞占比 `block usage`. 表示线程被阻塞了，以及等待占比 `wait usage` 表示线程在等待状态。
```
3/10 snapshots sharing following 23 elements
```
在堆栈轨迹(`stack trace`)之前的最后一行告诉你，`Elasticsearch` 在几毫秘中进行了 10 次快照，然后发现拥有如下同样堆栈轨迹的线程在这 3 次中都出现了。
当然，`Elasticsearch` 如何收集热线程 `API` 提供的信息，是值得学习的。每过几个毫秒，`Elasticsearch` 就会收集每个线程的持续时间、状态(等待阻塞)等待持续时间以及阻塞持续时间等相关的信息。过了指定的时间间隔(默认是 500 毫秒)，`Elasticsearch` 会对同样的信息进行第二轮收集操作。在每次收集过程中，它会对每个堆栈轨迹拍摄快照。用户可以通过向热线程 `API` 请求添加参数，来调整信息收集的过程：
```
GET /_nodes/hot_threads?type=wait&interval=1000ms&threads=3
```
- `type`——`cpu`、`wait` 和 `block` 之一。需要快照的线程状态类型。
- `interval`——第一次和第二次检查之间的等待时间。默认是 500 毫秒。
- threads——排名靠前的“热”线程的展示数量。 
### 线程池
集群中的每个节点通过线程池来管理 `CPU` 和内存的使用。`Elasticsearch` 将试图使用线程池以获得更好的节点性能。在某些情况下，需要手动地配置并修改线程池管理的方式，来避免失败累积（雪崩效应）的场景。在负载很重的情况下，`Elasticsearch` 可能会解化出上千个线程来处理请求，导致集群宕机。想要理解如何调优线程池，就需要精通应用程序使用 `Elasticsearch API` 的知识。举例来说，对于一个主要使用 `bulk` 索引 `API` 的应用程序，我们需要为其分配较多的线程。否则，`bulk index` 请求就会变得负载很重，而新进来的请求就会被忽略。
可以在集群配置中调节线程池的设置。线程池按照操作进行划分，并根据操作的类型配置默认值。为了简洁起见，这里只列出其中少数几个。
- `bulk`——默认是固定的值，基于可用于所有 `bulk` 批量操作的处理器数量。
- `index`——默认是周定的值，基于可用于索引和删除操作的处理器数量。
- `search`——默认是固定的值，3倍可用于计数和搜索操作的处理器数量。
查阅 `elasticsearch.yml` 配置，可以看到能为所有的批量操作增加线程池队列的大小，以及线程池的数量。请注意，集群设置 API 也允许用户在运行中的集群上更新这些设置
