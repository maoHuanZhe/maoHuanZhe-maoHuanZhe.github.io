---
title: 搜索请求的结构
date: 2022-04-19 20:26:29
permalink: /pages/5785d3/
categories:
  - Elasticsearch
  - 搜索数据
tags:
  - 
author: 
  name: 樊光瑞
  link: https://github.com/maoHuanZhe
---

`Elasticsearch` 的搜索是基于 `JSON` 文档或者是基于 `URL` 的请求。请求被发送到服务器，由于所有搜索请求遵循同样的格式，理解对于每个搜索请求所能修改的模块，是非常有帮助的。在讨论不同的模块之前，我们需要探讨搜索请求的范围。

## 确定搜索范围

所有的 `REST` 搜索请求使用 `_search` 的 `REST` 端点，既可以是 `GET` 请求，也可以是 `POST` 请求。既可以搜索整个集群，也可以通过在搜索 `URL` 中指定索引或类型的名称来限制范围。代码清单 4-1 提供了搜索 `URL` 的样例，它们用于限制搜索的范围。

::: warning 代码清单 4-1 在URL中限制搜索的范围

```http
GET /_search //搜索整个集群
GET /get-together/_search // 搜索 get-together 索引
GET /_all/_search //在全部索引中搜索
GET /*/_search   //在全部索引中搜索
GET /get-together,myindex/_search //在多个索引中搜索
GET /get-together,*index/_search  //使用通配符配置索引
```

::: 

还可以使用别名来搜索多个索引。这个方法经常用于搜索所有基于时间戳的索引。想想看以 `logstash-yymmdd` 格式来命令的索引，一个 `logstash` 的别名就可以指向所有相关索引。这样，可以进行一个基础的索引，将其限制在所有基于 `logstash` 的索引：`GET /logstash/_search`。为了获得更好的性能，尽可能地将查询限制在最小数量地索引和类型，原因是任何 `Elasticsearch` 不必搜索地内容都意味着可以有更快地响应速度。请记住每个必须发送到所有索引分片地搜索请求。搜索请求发送到越多地索引，那么就会涉及越多地分片。

现在知道了如何限制搜索请求地范围，下一步就是讨论搜索请求地基本模块。

## 搜索请求的基本模块

一旦选择了要搜索的索引，就需要配置搜索请求中最为重要的模块。这些模块涉及文档返回的数量，选择最佳的文档返回，以及配置不希望哪些文档出现在结果中。

- `query` ——这是搜索请求中最重要的组成部分，它配置了基于评分返回的最佳文档，也包括了你不希望返回哪些文档。该模块使用查询 `DSL` 和过滤器 `DSL` 来配置。一个例子就是使用标题中的关键词 `elasticsearch` 来搜索全部的事件，限定到了今年的事件。
- `size`——代表了返回文档的数量。
- `from`——和 `size` 一起使用，`from` 用于分页操作。需要注意的是，为了确定第 2 页的 10 项结果， `Elasticsearch` 必须要计算前 20 个结果。如果结果集合不断增加，获取某些靠后的翻页将会成为代价高昂的操作。
- `_source`——指定 `_source` 字段如何返回。默认是返回完整的 `_source` 字段。通过配置 `_source` ，将过滤返回的字段。如果索引的文档很大，而且无须结果中的全部内容，就使用这个功能。请注意，如果想使用它，就不能在索引映射中关闭 `_source` 字段。请参考下面的注意事项，来看看使用 `field`和 `_source` 之间的区别。
- `sort`——默认的排序是基于文档的得分。如果并不关心得分，或者期望许多文档的得分相同，添加额外的 `sort` 将帮助你控制哪些文档被返回。

::: tips 注意

在 `Elasticsearch` 版本 1 之前，`field` 是用于过滤返回字段的组件。这还是可能的，其行为就是返回可用的存储字段。如果没有存储的字段可使用，字段就从源（`source`）获取。如果在索引中没有显示地存储字段，最好使用 `_source` 模块。如果使用了 `_source` 过滤，`Elasticsearch` 就没有必要在获取 `_source` 中地字段之前，首先检查存储地字段。

:::

### 结果起始和页面大小

命名适宜的 `from` 和 `size` 字段，用于指定结果的开始点，以及每“页”结果的数量。举个例子，如果发送的 `from` 值是 7，`size` 值是5，那么 `Elasticsearch` 将返回第8、9、10、11 和 12 项结果（由于 `from` 参数是从 0 开始，指定 7 就是从第 8 项结果开始）。如果没有发送这两个参数，`Elasticsearch` 默认从第一项结果开始（第 0项结果），在回复中返回 10 项结果。有两种不同的方式向 `Elasticsearch` 发送搜索请求。

下一节会讨论如何发送基于 `URL` 的搜索请求。之后将讨论基于请求主体的搜索请求。刚刚讨论的搜索请求基本模块在这两种方式下都可以使用。

### 基于 URL 的搜索请求

这个部分将使用之前讨论的 4 个基本模块来创建基于 `URL` 的搜索请求。基于 `URL` 的搜索对于快速的 `curl` 请求而言是非常有用的。并非所有的搜索特性都是可以用在基于 `URL` 的搜索中。在代码清单 4-2 中，搜索请求将会搜索所有的活动，不过只需要第 2 页的 10 项结果。

::: warning 代码清单 4-2 使用 from 和 size 参数来实现结果分页

```http
//请求匹配了所有文档，URL中发送了from 和 size 参数
GET /get-together/_search?from=10&size=10
```

:::
代码清单 4-3 创建了搜索请求，返回默认的前 10 个活动，不过是按照活动日期的升序来排列的。如果需要，可以综合这两个搜索请求的配置。尝试同样的搜索请求，将排序换为降序(`desc`)，检查一下活动的排序是否发生改变。

::: warning 代码清单 4-3 改变结果的顺序

```http
//请求匹配了所有文档，但是默认返回前 10 项结果，按照日期地升序排列
GET /get-together/_search?sort=date:asc
```

:::

代码清单 4-4 限制了回复中地 `source` 字段。假想以下，你只需要获得标题和日期。此外，你希望活动按照日期排序。这里配置了 `_source` 模块，只请求了标题和日期。在下一章中，当我们讨论基于请求主体地搜索时，将会解释更多关于 `_source` 的选项。代码清单 4-4 中的回复展示了 1 个命中结果。

::: warning 代码清单 4-4 在你期望的回复中限制 _source 的字段

```http
//请求匹配所有的文档，但是默认只返回前 10 项结果，这些结果按照日期升序排列。你只想要 2 个字段：标题和日期
GET /get-together/_search?sort=date:asc&_source=title,date
// 展示回复中的 1 个命中结果
{
    "_index" : "get-together",
    "_id" : "112",
    // 文档得分是 null，原因是你正在使用 sort 参数，因此不会为文档计算分数
    "_score" : null,
    "_routing" : "5",
    "_source" : {
    	// 被过滤后的 _source 文档目前只包含过滤的字段
        "date" : "2013-02-18T18:30",
        "title" : "real-time Elasticsearch"
    },
	"sort" : [
		1361212200000
	]
}
```

:::

目前为止，只用了 `match_all` 查询来创建搜索请求。查询和过滤器的 `DSL` 将在 4.2 节中探讨。但是下面这件事情还是非常重要的，那就是如何创建基于 `URL` 的搜索请求，从而只返回标题中含有 `elasticsearch` 字样的文档。同样，这里按照日期来排序。请注意  `q=title:elasticsearch` 部分。这里指定了在标题字段中查询关键词`elasticscarch`，如代码清单 4-5 所示。

::: warning 代码清单 4-5 更改结果的排序

```http
// 请求匹配了所有标题中含有 elasticsearch 字样的活动
GET /get-together/_search?sort=date:asc&q=title:elasticsearch
```

:::

使用 `q=` 表明你希望在搜索请求中提供一个查询。使用 `title:elasticsearch` 表明了正在 `title` 字段中查找关键词 `elasticsearch`。

请自己尝试这个查询，并且检视返回的内容，其中只会包含标题有 `elasticsearch` 字样的活动。尽量尝试其他的关键词和字段。此外，还可以在一个查询中组合所提到的搜索 `API` 模块。

现在你已经适应了使用 `URL` 的搜索请求，按下来将学习基于请求主体的搜索请求。

## 基于请求主体的搜索请求

前一节展示了如何在基于 `URL` 的查询中使用基础的搜索请求模块。如果使用命令行模式，这是一种与 `Elasticsearch` 交互很好的方式。当执行更多高级搜索的时候，采用基于请求主体的搜索会使得你拥有更多的灵活性和选择性。即使是使用基于请求主体的搜索，某些模块同样可以通过 `URL` 来提供。由于前一节已经讨论了所有基于 `URL` 的配置，因此在本节中我们将集中讨论请求主体。代码清单 4-6 中的例子匹配了 `get-together` 索引所有的文档，并搜索了其中的第二页。

::: warning 代码清单 4-6 使用 from 和 size 参数来实现结果分页

```http
GET /get-together/_search
{
  "query": {
    "match_all": {}
  },
  "from": 10, // 返回从第 10 项开始的结果
  "size": 10  // 总共返回最多 10 个结果
}
```

:::

你可能注意到了 `query` 部分，这是每个查询中的一个对象，现在还不用担心 `match_all` 部分。在 4.2 节有关查询和过滤器 `DSL` 的内容中，我们将讨论这个。

### 结果中返回的字段

下一个所有搜索请求共享的元素是对于每个匹配文档而言，`Elasticsearch` 所应该返回的字段列表。这是通过在搜索请求中发送  `_source` 模块来指定的。如果请求中没有指定 `_source` `Elasticsearch` 默认返回整个`_source`， 或者，如果 `_source` 没有存储，那么就只返回匹配文档的元数据：`_index` 、 `_id` 和 `_score`。

代码清单 4-7 使用了之前的查询，返回了每个匹配分组的 `name` 和 `date` 字段。

::: warning 代码清单 4-7 过滤返回的 _source 内容_

```http
GET /get-together/_search
{
  "query": {
    "match_all": {}
  },
  "_source": ["name","date"] // 搜索回复中返回名字和日期字段
}
```

:::

###  _source 返回字段中的通配符

你不仅可以返回字段列表，还可以指定通配符。例如，如果想同时返回 `name` 和 `nation` 字段，可以这样配置 `source: "na*"`。也可以使用通配字符串的数组来指定多个通配符，例如 `_source:["name.*", "address.*"]`。

不仅可以指定哪些字段需要返回，还可以指定哪些字段无须返回。代码清单 4-8 给出了一个例子。

::: warning 通过 include 和 exclude 过滤返回的 _source 内容

```
GET /get-together/_search
{
  "query": {
    "match_all": {}
  },
  "_source": {
    "includes": ["location_event.*","date"], //在搜索回复中返回以 location_event 开头的字段和日期字段
    "excludes": ["location_event.geolocation"] //不要返回 location_event.geolocation 字段
  }
}
```

:::

### 结果的排序

大多搜索最后涉及的元素都是结果的排序（`sort`)。如果没有指定 `sort` 排序选项，`Elasticsearch`返回匹配的文档的时候，按照 `_score` 取值的降序来排列，这样最为相关的（得分最高的）文档就会排名在前。为了对字段进行升序或降序排列，指定映射的数组，而不是字段的数组。通过在 `sort`中指定字段列表或者是字段映射，可以在任意数量的字段上进行排序。例如，使用之前的组织者搜索，返回结果时可以先按照创建日期来排序，从最老的开始。然后根据 `get-together` 分组的名字来排序，按照倒排的字母顺序。最后，按照 `_score` 得分来排序，如代码清单4-9 所示。

::: warning 代码清单 4-9 按照日期（升序）、名称（降序）和 _score 来排列的结果

```http
GET /get-together/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    { "created_on": "asc" },//首先创建按照日期来排序，从最老的到最新的
    { "name": "desc" },//然后按照分组的名称来排序，按倒排的字母顺序
    "_score"//最终，按照相关性得分(_score)来排序
  ]
}
```

:::

::: tips 在多值和分析字段上排序

当在多值字段（如 `tags`）上排序时，你无法知道排序怎样使用这些数值。系统将选择一个值来参加排序，但是你不知道是哪个。对于分析过的字段而言，同样如此。一个经过分析的字段，通常也会产生多个词条。因此最好根据非分析或者数值型字段来进行排序。

:::

### 实践中的基础模块

现在我们已经涵盖了基本的搜索模块，代码清单 4-10 展示了一个搜索请求的样例，使用了所有的基础模块。

::: warning 代码清单 4-10 使用 4 个元素的查询：范围、分页、字段和排序

```http
GET /get-together/_search
{
  "query": {
    "match_all": {}
  },
  "from": 0, //从第一个（第0个）结果开始
  "size": 10,//总共返回10个结果
  "_source": ["name","organizer","description"],//包含了分组名称，组织者和分组描述
  "sort": [
    {
      "created_on": {
        "order": "desc" // 按照 create_on 字段的降序来排列
      }
    }
  ]
}
```

:::

在深入查询和过滤器 `API` 的细节之前，需要先了解另一项内容：搜索回复的结构。

### 理解回复的结构

接下来看一个搜索的样例，以及其结果响应是什么样子。代码清单 4-11 搜索了关于 `elasticsearch` 的分组。为了简洁，这里使用了基于 `URL` 的搜索。

::: warning 代码清单 4-11 样例搜索请求和回复

```http
GET /_search?q=title:elasticsearch&_source=title,date
{
  "took" : 86, //查询所用的毫秒数
  "timed_out" : false,//表明是否有分片超时，也就是说是否只返回了部分结果
  "_shards" : {
    "total" : 14,
    "successful" : 14, //成功响应应该请求和未能成功响应 该请求的分片数量
    "skipped" : 0,
    "failed" : 0
  },
  "hits" : { //回复中包含了命中(hits)的键，其值是命中文档的数组
    "total" : {
      "value" : 7,//该搜索请求所有匹配结果的数量
      "relation" : "eq"
    },
    "max_score" : 0.6292531,//这个搜索结果中的最大得分
    "hits" : [//命中(hits)关键词元素中的命中文档数组
      {
        "_index" : "get-together",//结果文档的索引
        "_id" : "103",//结果文档的ID
        "_score" : 0.6292531,//结果的相关性得分
        "_routing" : "2",
        "_source" : {//请求的 _source 字段(本例中是标题和日期)
          "date" : "2013-04-17T19:00",
          "title" : "Introduction to Elasticsearch"
        }
      },
      {
        "_index" : "get-together",
        "_id" : "105",
        "_score" : 0.6292531,
        "_routing" : "2",
        "_source" : {
          "date" : "2013-07-17T18:30",
          "title" : "Elasticsearch and Logstash"
        }
      }
   ]
}
```

:::

请记住，如果没有存储文档的 `_source` 或者是 `fields`，那么将无法从 `Elasticsearch` 中获取数值！

现在你已经熟悉了搜索请求的基本模块，还有一个模块尚未仔细探讨，那就是查询和过滤器 `DSL`。这是有意为之的，因为这个话题实在是太大了，需要单独的一节来讨论。
