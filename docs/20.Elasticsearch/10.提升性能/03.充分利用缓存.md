---
title: 充分利用缓存
date: 2022-04-19 20:51:52
permalink: /pages/9cb31b/
categories:
  - Elasticsearch
  - 提升性能
tags:
  - 
author: 
  name: 樊光瑞
  link: https://github.com/maoHuanZhe
---
`Elasticsearch` 的强项之一(尽管不是最强项)就是你可以使用普通的硬件，在毫秒级查询数十亿的文档。使这成为可能的原因之一是智能的缓存。你可能已经注意到了，索引了大量的数据之后，第二次的查询速度可能比第一次的快上几个数量级。这都是因为缓存，例如，当你组合了过滤器和查询，过滤器缓存就会扮演一个重要的角色，让搜索运行得更快。
在本节中，我们将讨论过滤器缓存以及其他两种类型的缓存：分片查询缓存以及操作系统缓存。在静态索引上运行聚集的时候，分片查询缓存非常有用，因为它缓存了整个结果。而操作系统缓存，通过将索引缓存到内存中，来保持高速的 `I/O` 吞吐量。
最后，我们将向你展示在每次刷新之后，如何使用索引预热器来运行查询，并保持缓存处于热身状态。让我们先从 `Elasticsearch` 相关缓存的主要类型——过滤器缓存，以及如何运行搜索来充分利用该缓存开始。
## 过滤器和过滤器缓存
在第 4 章中，你看到很多查询都有对等的过滤器。让我们假设你想在 `get-together` 站点上查找最近一个月开展的活动。为了实现这个目标，可以使用范围查询或者是对等的范围过滤器。
在第 4 章，我们提到对于这两者，推荐使用过滤器，因为它是被缓存的。
### 过滤器缓存
过滤器的结果被缓存之后会存储在过滤器缓存中。这种缓存分配在节点之上，就像之前看到的索引缓冲。其默认的值是 10%，不过可以按照需要，在 `elasticsearch.yml` 中修改这个值。如果你经常使用过滤器，增加这个大小是很有意义的。例如：
```
indices.queries.cache.size: 30%
```
你怎么知道是否需要更多（或更少）的缓存？监控实际的使用情况。在第 11 章的管理篇，我们将探索这个话题。`Elasticsearch` 使用了很多度量指标，包括实际使用的过滤器缓存容量，以及缓存回收(`eviction`)的次数。当缓存已满，`Elastiesearch` 需要将近期最少使用(`LRU`)的条目移出缓存，为新的缓存内容留出空间，这时就会发生回收操作。
在某些使用场景中，过滤器缓存条目的生命周期非常短暂。举个例子，用户经常使用特定的主题来过滤 `get-together` 活动，修改查询直到发现他们所想要的，然后离开。如果没有其他人搜索同样主题的活动，那么相应的缓存条目在内存中逗留却无法发挥作用，直到最终被回收。回收操作很多的缓存会使得性能下降。因为每次搜索时，都要回收旧的缓存条目来容纳新的条目，这需要消耗 `CPU` 的计算周期。
在这种情况下，为了防止恰好在查询执行的时候发生回收，设置缓存条目的生存时间(`TTL`)是很有意义的。你可以调整 `indices.requests.cache.expire` 来实现这个目的。例如，在下面的设置，过滤器缓存将在 30 分钟后过期。
```
indices.requests.cache.expire: 30m
```
除了确保你的过滤器缓存有足够的空间，还需要合理使用过滤器，使其充分利用这些缓存。
::: node 更新内容
可以使用 `indices.requests.cache.expire` 设置为缓存结果指定 `TTL`，但应该没有理由这样做。请记住，刷新索引时，过时的结果会自动失效。此设置仅用于完整性。
[官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/8.1/shard-request-cache.html#_cache_settings)
:::
